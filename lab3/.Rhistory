plot(mod1, which=22)
sort(influence(mod1)$hat)
?crPlots
set.seed(6886)
data(faithful)
of = faithful
plot(of, col="blue",main="Eruptions of Old Faithful")
## Run three regressions (1 restricted, 2 unrestricted)
r.reg = lm(waiting ~ eruptions, data = of)
ur.reg1 = lm(waiting ~ eruptions, data = of[of$eruptions > 3.25,])
ur.reg2 = lm(waiting ~ eruptions, data = of[of$eruptions
## review the regression results
summary(reg.r)
summary(ur.reg1)
summary(ur.reg2)
## Calculate sum of squared residuals for each regression
SSR = NULL
SSR$r = r.reg$residuals^2
SSR$ur1 = ur.reg1$residuals^2
SSR$ur2 = ur.reg2$residuals^2
## K is the number of regressors in our model
K = r.reg$rank
## Computing the Chow test statistic (F-test)
numerator = ( sum(SSR$r) - (sum(SSR$ur1) + sum(SSR$ur2)) ) / K
denominator = (sum(SSR$ur1) + sum(SSR$ur2)) / (nrow(of) - 2*K)
chow = numerator / denominator
chow
## Calculate P-value
1-pf(chow, K, (nrow(of) - 2*K))
## Plot the results
plot(of,main="Eruptions of Old Faithful")
# restricted model
abline(r.reg, col = "red",lwd = 2, lty = "dashed")
# unrestricted model 1
segments(0, ur.reg2$coefficients[1], 3.25,
ur.reg2$coefficients[1]+3.25*ur.reg2$coefficients[2], col= 'blue')
# unrestricted model 2
segments(3.25, ur.reg1$coefficients[1]+3.25*ur.reg1$coefficients[2],
5.2, ur.reg1$coefficients[1]+5.2*ur.reg1$coefficients[2], col= 'blue')
## Sort the data
sort.of = of[order(of$eruptions) , ]
sort.of = cbind(index(sort.of),sort.of)
## Identify the row number of our breakpoint
brk = max(sort.of[,1][sort.of$eruptions brk
## Using the CRAN package 'strucchange'
require(strucchange)
sctest(waiting ~ eruptions, type = "Chow", point = brk, data = sort.of)
of$dummy = as.numeric(of$eruptions >= 3.25)
summary(lm(eruptions ~ waiting + I(dummy*waiting) + dummy, data = of))
set.seed(6886)
data(faithful)
of = faithful
plot(of, col="blue",main="Eruptions of Old Faithful")
## Run three regressions (1 restricted, 2 unrestricted)
r.reg = lm(waiting ~ eruptions, data = of)
ur.reg1 = lm(waiting ~ eruptions, data = of[of$eruptions > 3.25,])
ur.reg2 = lm(waiting ~ eruptions, data = of[of$eruptions
## review the regression results
summary(reg.r)
summary(ur.reg1)
summary(ur.reg2)
## Calculate sum of squared residuals for each regression
SSR = NULL
SSR$r = r.reg$residuals^2
SSR$ur1 = ur.reg1$residuals^2
SSR$ur2 = ur.reg2$residuals^2
## K is the number of regressors in our model
K = r.reg$rank
## Computing the Chow test statistic (F-test)
numerator = ( sum(SSR$r) - (sum(SSR$ur1) + sum(SSR$ur2)) ) / K
denominator = (sum(SSR$ur1) + sum(SSR$ur2)) / (nrow(of) - 2*K)
chow = numerator / denominator
chow
## Calculate P-value
1-pf(chow, K, (nrow(of) - 2*K))
## Plot the results
plot(of,main="Eruptions of Old Faithful")
# restricted model
abline(r.reg, col = "red",lwd = 2, lty = "dashed")
# unrestricted model 1
segments(0, ur.reg2$coefficients[1], 3.25,
ur.reg2$coefficients[1]+3.25*ur.reg2$coefficients[2], col= 'blue')
# unrestricted model 2
segments(3.25, ur.reg1$coefficients[1]+3.25*ur.reg1$coefficients[2],
5.2, ur.reg1$coefficients[1]+5.2*ur.reg1$coefficients[2], col= 'blue')
## Sort the data
sort.of = of[order(of$eruptions) , ]
sort.of = cbind(index(sort.of),sort.of)
## Identify the row number of our breakpoint
brk = max(sort.of[,1][sort.of$eruptions<=3.25)]
brk = max(sort.of[,1][sort.of$eruptions<=3.25])
brk
sort.of[97:99,]
library(strucchange)
sctest(waiting ~ eruptions, type = "Chow", point = brk, data = sort.of)
of$dummy = as.numeric(of$eruptions >= 3.25)
summary(lm(eruptions ~ waiting + I(dummy*waiting) + dummy, data = of))
set.seed(6886)
par(mfrow=c(1,1))
data(faithful)
of = faithful
plot(of, col="blue",main="Eruptions of Old Faithful")
## Run three regressions (1 restricted, 2 unrestricted)
r.reg = lm(waiting ~ eruptions, data = of)
ur.reg1 = lm(waiting ~ eruptions, data = of[of$eruptions > 3.25,])
ur.reg2 = lm(waiting ~ eruptions, data = of[of$eruptions
## review the regression results
summary(reg.r)
summary(ur.reg1)
summary(ur.reg2)
## Calculate sum of squared residuals for each regression
SSR = NULL
SSR$r = r.reg$residuals^2
SSR$ur1 = ur.reg1$residuals^2
SSR$ur2 = ur.reg2$residuals^2
## K is the number of regressors in our model
K = r.reg$rank
## Computing the Chow test statistic (F-test)
numerator = ( sum(SSR$r) - (sum(SSR$ur1) + sum(SSR$ur2)) ) / K
denominator = (sum(SSR$ur1) + sum(SSR$ur2)) / (nrow(of) - 2*K)
chow = numerator / denominator
chow
## Calculate P-value
1-pf(chow, K, (nrow(of) - 2*K))
## Plot the results
plot(of,main="Eruptions of Old Faithful")
# restricted model
abline(r.reg, col = "red",lwd = 2, lty = "dashed")
# unrestricted model 1
segments(0, ur.reg2$coefficients[1], 3.25,
ur.reg2$coefficients[1]+3.25*ur.reg2$coefficients[2], col= 'blue')
# unrestricted model 2
segments(3.25, ur.reg1$coefficients[1]+3.25*ur.reg1$coefficients[2],
5.2, ur.reg1$coefficients[1]+5.2*ur.reg1$coefficients[2], col= 'blue')
## Sort the data
sort.of = of[order(of$eruptions) , ]
sort.of = cbind(index(sort.of),sort.of)
## Identify the row number of our breakpoint
brk = max(sort.of[,1][sort.of$eruptions<=3.25])
## Using the CRAN package 'strucchange'
library(strucchange)
sctest(waiting ~ eruptions, type = "Chow", point = brk, data = sort.of)
of$dummy = as.numeric(of$eruptions >= 3.25)
summary(lm(eruptions ~ waiting + I(dummy*waiting) + dummy, data = of))
# First convert data into two lets say random subsamples
set.seed(6886)
par(mfrow=c(1,1))
data(faithful)
of = faithful
plot(of, col="blue",main="Eruptions of Old Faithful")
## Run three regressions (1 restricted, 2 unrestricted)
r.reg = lm(waiting ~ eruptions, data = of)
ur.reg1 = lm(waiting ~ eruptions, data = of[of$eruptions > 3.25,])
ur.reg2 = lm(waiting ~ eruptions, data = of[of$eruptions <=3.25,])
## review the regression results
summary(reg.r)
summary(ur.reg1)
summary(ur.reg2)
## Calculate sum of squared residuals for each regression
SSR = NULL
SSR$r = r.reg$residuals^2
SSR$ur1 = ur.reg1$residuals^2
SSR$ur2 = ur.reg2$residuals^2
## K is the number of regressors in our model
K = r.reg$rank
## Computing the Chow test statistic (F-test)
numerator = ( sum(SSR$r) - (sum(SSR$ur1) + sum(SSR$ur2)) ) / K
denominator = (sum(SSR$ur1) + sum(SSR$ur2)) / (nrow(of) - 2*K)
chow = numerator / denominator
chow
## Calculate P-value
1-pf(chow, K, (nrow(of) - 2*K))
## Plot the results
plot(of,main="Eruptions of Old Faithful")
# restricted model
abline(r.reg, col = "red",lwd = 2, lty = "dashed")
# unrestricted model 1
segments(0, ur.reg2$coefficients[1], 3.25,
ur.reg2$coefficients[1]+3.25*ur.reg2$coefficients[2], col= 'blue')
# unrestricted model 2
segments(3.25, ur.reg1$coefficients[1]+3.25*ur.reg1$coefficients[2],
5.2, ur.reg1$coefficients[1]+5.2*ur.reg1$coefficients[2], col= 'blue')
## Sort the data
sort.of = of[order(of$eruptions) , ]
sort.of = cbind(index(sort.of),sort.of)
## Identify the row number of our breakpoint
brk = max(sort.of[,1][sort.of$eruptions<=3.25])
## Using the CRAN package 'strucchange'
library(strucchange)
sctest(waiting ~ eruptions, type = "Chow", point = brk, data = sort.of)
of$dummy = as.numeric(of$eruptions >= 3.25)
summary(lm(eruptions ~ waiting + I(dummy*waiting) + dummy, data = of))
rm(list=ls())
# Function to load packages
loadPkg=function(toLoad){
for(lib in toLoad){
if(! lib %in% installed.packages()[,1])
{ install.packages(lib, repos='http://cran.rstudio.com/') }
suppressMessages( library(lib, character.only=TRUE) ) }
}
# Load libraries
packs=c("ggplot2", 'lmtest', 'car', 'sandwich')
loadPkg(packs)
# Set a theme for gg
theme_set(theme_bw())
# Functions that I use frequently
char = function(x){ as.character(x) }
num = function(x){ as.numeric(char(x)) }
# Relevant paths
labPath='~/Dropbox/Duke/Spring 2015/PS 733/lab3'
# Load data
msrepPath=paste0(labPath, "/Msrepl87.asc")
msrep = read.table(msrepPath, header=TRUE)
# Create silly logged version of DV
msrep$deaths75ln = log(msrep$deaths75+1)
# Create logs of other things
msrep$deaths70ln = log(msrep$deaths70+1)
msrep$sanctions75ln = log(msrep$sanctions75+1)
msrep$sanctions70ln = log(msrep$sanctions70+1)
msrep$energypcln = log(msrep$energypc+1)
cor(msrepRegData[,c('deaths75ln', 'upper20', 'sanctions75ln')])
ivs=c('upper20', 'energypcln', 'intensep',
'sanctions70ln', 'sanctions75ln', 'deaths70ln')
msrepRegData=na.omit(msrep[,c('deaths75ln', ivs)])
ivs=c('upper20', 'energypcln', 'intensep',
'sanctions70ln', 'sanctions75ln', 'deaths70ln')
msrepRegData=na.omit(msrep[,c('deaths75ln', ivs)])
cor(msrepRegData[,c('deaths75ln', 'upper20', 'sanctions75ln')])
cor(msrepRegData[,c('deaths75ln', 'upper20', 'sanctions75ln')])
ivs=c('upper20', 'energypcln', 'intensep',
'sanctions70ln', 'sanctions75ln', 'deaths70ln')
msrepRegData=na.omit(msrep[,c('deaths75ln', ivs)])
coeftest( lm(deaths75ln ~ upper20 + sanctions75ln, data=msrepRegData) )
summary(lm(deaths75ln ~ upper20 + sanctions75ln, data=msrepRegData))$coefficients
cor(msrepRegData[,c('deaths75ln', 'upper20', 'sanctions75ln')])
coeftest( lm(deaths75ln ~ upper20 + sanctions75ln, data=msrepRegData) )
coeftest( lm(deaths75 ln ~ upper20, data=msrepRegData) )
coeftest( lm(deaths75ln ~ upper20, data=msrepRegData) )
coeftest( lm(deaths75ln ~ sanctions75ln, data=msrepRegData) )
# How to assess effects of misspecification from OVB
# Bivariate case
cor(msrepRegData[,c('deaths75ln', 'upper20', 'sanctions75ln')])
coeftest( lm(deaths75ln ~ upper20 + sanctions75ln, data=msrepRegData) )
# If we excluded sanctions75ln from the model what would you expect of the
# coefficient on upper20
coeftest( lm(deaths75ln ~ upper20, data=msrepRegData) )
# If we excluded upper20 from the model what would you expect of the
# coefficient on sanctions75ln
coeftest( lm(deaths75ln ~ sanctions75ln, data=msrepRegData) )
# More complicated model
# Harder to assess direction of bias in these cases
ivs=c('upper20', 'energypcln', 'intensep',
'sanctions70ln', 'sanctions75ln', 'deaths70ln')
msrepRegData=na.omit(msrep[,c('deaths75ln', ivs)])
cor(msrepRegData)
olsForm1=formula(paste0('deaths75ln ~ ', paste(ivs, collapse=' + ')))
olsForm2=formula(paste0('deaths75ln ~ ', paste(ivs[c(2:length(ivs))], collapse=' + ')))
mod1 = lm(olsForm1, data=msrepRegData)
mod2 = lm(olsForm2, data=msrepRegData)
# View model results
summary(mod1)
summary(mod2)
olsForm1
olsForm1
olsForm2
length(ivs)
ssr1=sum(resid(mod1)^2)
ssr2=sum(resid(mod2)^2)
chgReg=ncol(model.matrix(mod1)) - ncol(model.matrix(mod2))
# F statistic
Fstat=((ssr1-ssr2)/chgReg)/(ssr1/df.residual(mod1))
Fstat
((sum(mod1$residuals ^ 2) - sum(mod2$residuals ^ 2)) / (mod1$rank - mod2$rank)) / (sum(mod1$residuals ^ 2) / mod1$df.residual)
ssr1 = (sum(mod1$residuals ^ 2)
ssr1=sum(resid(mod1)^2)
ssr2=sum(resid(mod2)^2)
chgReg=ncol(model.matrix(mod1)) - ncol(model.matrix(mod2))
Fstat=((ssr1-ssr2)/chgReg)/(ssr1/df.residual(mod1))
ssr1=sum(resid(mod1)^2)
ssr2=sum(resid(mod2)^2)
chgReg=ncol(model.matrix(mod1)) - ncol(model.matrix(mod2))
# F statistic
Fstat=((ssr1-ssr2)/chgReg)/(ssr1/df.residual(mod1))
Fstat
?pf
chgReg
df.residual(mod1)
abs(Fstat)
pf(abs(Fstat), chgReg, df.residual(mod1))
1-pf(abs(Fstat), chgReg, df.residual(mod1))
anova(mod1, mod2)
ltest=nrow(model.matrix(mod2))*log(ssr1/ssr2)
ltest
f<- function(mod1,mod2){{length(resid(mod1))*log(sum(resid(mod2)^2)/sum(resid(mod1)^2))}}
f(mod1,mod2)
val=1
return(val)
likeRatTest <- function(full,restr){
n=length(resid(full))
ssrF=sum(resid(full)^2)
ssrR=sum(resid(restr)^2)
val=n*log(ssrR/ssrF)
return(val)
}
likeRatTest(mod1,mod2)
likeRatTest <- function(full,restr){
n=length(resid(full))
ssrF=sum(resid(full)^2)
ssrR=sum(resid(restr)^2)
val=n*log(ssrR/ssrF)
chgReg=ncol(model.matrix(full)) - ncol(model.matrix(restr))
pval = 1-pchisq(val,chgReg)
return(c(val, pval))
}
likeRatTest(mod1,mod2)
likeRatTest <- function(full,restr){
n=length(resid(full))
ssrF=sum(resid(full)^2)
ssrR=sum(resid(restr)^2)
val=n*log(ssrR/ssrF)
chgReg=ncol(model.matrix(full)) - ncol(model.matrix(restr))
pval = 1-pchisq(val,chgReg)
output=round(c(val, pval),5)
names(output)=c('Likelihood Ratio', 'P-value')
return(output)
}
likeRatTest(mod1,mod2)
crPlots(mod1)
olsForm3=formula('deaths75ln ~ poly(upper20,2) + energypcln + intensep +
sanctions70ln + sanctions75ln + deaths70ln')
mod3=lm(olsForm3, data=msrepRegData)
msrepRegData$upper20sq = msrepRegData$upper20^2
olsForm3=formula('deaths75ln ~ upper20 + upper20sq + energypcln + intensep +
sanctions70ln + sanctions75ln + deaths70ln')
olsForm3=formula('deaths75ln ~ poly(upper20,2) + energypcln + intensep +
sanctions70ln + sanctions75ln + deaths70ln')
mod3=lm(olsForm3, data=msrepRegData)
coeftest(mod3)
anova(mod1, mod3)
lrtest(mod1, mod3)
data(faithful)
of = faithful
plot(of, col="blue",main="Eruptions of Old Faithful")
r.reg = lm(waiting ~ eruptions, data = of)
ur.reg1 = lm(waiting ~ eruptions, data = of[of$eruptions > 3.25,])
ur.reg2 = lm(waiting ~ eruptions, data = of[of$eruptions <=3.25,])
coeftest(r.reg)
coeftest(ur.reg1)
coeftest(ur.reg2)
## Calculate sum of squared residuals for each regression
SSR = NULL
SSR$r = r.reg$residuals^2
SSR$ur1 = ur.reg1$residuals^2
SSR$ur2 = ur.reg2$residuals^2
## K is the number of regressors in our model
K = r.reg$rank
## Computing the Chow test statistic (F-test)
numerator = ( sum(SSR$r) - (sum(SSR$ur1) + sum(SSR$ur2)) ) / K
denominator = (sum(SSR$ur1) + sum(SSR$ur2)) / (nrow(of) - 2*K)
chow = numerator / denominator
chow
1-pf(chow, K, (nrow(of) - 2*K))
plot(of,main="Eruptions of Old Faithful")
# restricted model
abline(r.reg, col = "red",lwd = 2, lty = "dashed")
# unrestricted model 1
segments(0, ur.reg2$coefficients[1], 3.25,
ur.reg2$coefficients[1]+3.25*ur.reg2$coefficients[2], col= 'blue')
# unrestricted model 2
segments(3.25, ur.reg1$coefficients[1]+3.25*ur.reg1$coefficients[2],
5.2, ur.reg1$coefficients[1]+5.2*ur.reg1$coefficients[2], col= 'blue')
mod1
residMod1=resid(mod1)^2
bpForm=formula(paste0('residMod1 ~', paste(ivs, collapse=' + ')))
bpForm
bpMod=lm(bpForm, data=msrepRegData)
coeftest(bpMod)
summary(bpMod)$r.squared
nrow(msrepRegData)
bpStat=summary(bpMod)$r.squared*nrow(msrepRegData)
bpStat
1-pchisq(bpStat, df=length(ivs))
bptest(mod1)
par(mfrow=c(1,2))
plot(mod1, 1)
plot(predict(mod1), resid(mod1))
par(mfrow=c(1,2))
plot(mod1, 1)
plot(predict(mod1), resid(mod1))
stdResid=(resid(mod1)-mean(resid(mod1)))/sd(resid(mod1))
plot(mod1, 3)
plot(predict(mod1), sqrt(abs(stdResid)))
coeftest(mod1, vcov=vcovHC(mod1, type='HC1'))
coeftest(mod1, vcov=vcovHC(mod1, type='HC1'))
coeftest(mod1)
rm(list=ls())
# Function to load packages
loadPkg=function(toLoad){
for(lib in toLoad){
if(! lib %in% installed.packages()[,1])
{ install.packages(lib, repos='http://cran.rstudio.com/') }
suppressMessages( library(lib, character.only=TRUE) ) }
}
# Load libraries
packs=c("ggplot2", 'lmtest', 'car', 'gap', 'sandwich')
loadPkg(packs)
# Set a theme for gg
theme_set(theme_bw())
# Functions that I use frequently
char = function(x){ as.character(x) }
num = function(x){ as.numeric(char(x)) }
# Relevant paths
labPath='~/Dropbox/Duke/Spring 2015/PS 733/lab3'
msrepPath=paste0(labPath, "/Msrepl87.asc")
msrep = read.table(msrepPath, header=TRUE)
# Create silly logged version of DV
msrep$deaths75ln = log(msrep$deaths75+1)
# Create logs of other things
msrep$deaths70ln = log(msrep$deaths70+1)
msrep$sanctions75ln = log(msrep$sanctions75+1)
msrep$sanctions70ln = log(msrep$sanctions70+1)
msrep$energypcln = log(msrep$energypc+1)
msrepBiRegData=na.omit(msrep[,c('deaths75ln', 'upper20', 'sanctions75ln')])
cor(msrepBiRegData)
# Estimate coefficients
coeftest( lm(deaths75ln ~ upper20 + sanctions75ln, data=msrepBiRegData) )
# If we excluded sanctions75ln from the model what would you expect of the
# coefficient on upper20
coeftest( lm(deaths75ln ~ upper20, data=msrepBiRegData) )
# If we excluded upper20 from the model what would you expect of the
# coefficient on sanctions75ln
coeftest( lm(deaths75ln ~ sanctions75ln, data=msrepBiRegData) )
# More complicated model
ivs=c('upper20', 'energypcln', 'intensep',
'sanctions70ln', 'sanctions75ln', 'deaths70ln')
msrepRegData=na.omit(msrep[,c('deaths75ln', ivs)])
olsForm1=formula(paste0('deaths75ln ~ ', paste(ivs, collapse=' + ')))
olsForm2=formula(paste0('deaths75ln ~ ', paste(ivs[c(2:length(ivs))], collapse=' + ')))
mod1 = lm(olsForm1, data=msrepRegData)
mod2 = lm(olsForm2, data=msrepRegData)
# View model results
summary(mod1)
summary(mod2)
# How would we do a partial F-test
ssr1=sum(resid(mod1)^2)
ssr2=sum(resid(mod2)^2)
chgReg=ncol(model.matrix(mod1)) - ncol(model.matrix(mod2))
# F statistic
Fstat=((ssr1-ssr2)/chgReg)/(ssr1/df.residual(mod1))
1-pf(abs(Fstat), chgReg, df.residual(mod1))
# Using anova function from base R
anova(mod1, mod2)
# How to calculate the Breusch-Pagan test statistic
residMod1=resid(mod1)^2
bpForm=formula(paste0('residMod1 ~', paste(ivs, collapse=' + ')))
bpMod=lm(bpForm, data=msrepRegData)
bpStat=summary(bpMod)$r.squared*nrow(msrepRegData)
1-pchisq(bpStat, df=length(ivs))
# Breusch-Pagan test: using bptest from lmtest library
bptest(mod1)
summary(bpMod)$r.squared*nrow(msrepRegData)
tss=sum( (msrepRegData$deaths75ln - mean(msrepRegData$deaths75ln))^2 )
tss
rss=sum(resid(mod1)^2)
rss
.5(tss-rss)
.5*(tss-rss)
bpStat
ls()
olsForm1
(msrepRegData$deaths75ln - mean(msrepRegData$deaths75ln))^2
residMod1=resid(mod1)^2
bpForm=formula(paste0('residMod1 ~', paste(ivs, collapse=' + ')))
bpMod=lm(bpForm, data=msrepRegData)
bpStat=summary(bpMod)$r.squared*nrow(msrepRegData)
1-pchisq(bpStat, df=length(ivs))
tss=sum( (msrepRegData$deaths75ln - mean(msrepRegData$deaths75ln))^2 )
rss=sum(resid(mod1)^2)
.5*(tss-rss)
bpStat
sum(residMod1)/length(residMod1)
var(residMod1)
sd(residMod1)
residMod1=resid(mod1)^2
bpForm=formula(paste0('residMod1 ~', paste(ivs, collapse=' + ')))
bpMod=lm(bpForm, data=msrepRegData)
bpStat=summary(bpMod)$r.squared*nrow(msrepRegData)
1-pchisq(bpStat, df=length(ivs))
residMod1=resid(mod1)^2
norm=sum(residMod1)/length(residMod1)
residModNorm1=residMod1/norm
bpForm2=formula(paste0('residModNorm1 ~', paste(ivs, collapse=' + ')))
bpMod2=lm(bpForm2, data=msrepRegData)
tss=sum( (msrepRegData$deaths75ln - mean(msrepRegData$deaths75ln))^2 )
rss=sum(resid(bpMod2)^2)
.5*(tss-rss)
bpStat
resid(bpMod2)
residMod1=resid(mod1)^2
bpForm=formula(paste0('residMod1 ~', paste(ivs, collapse=' + ')))
bpMod=lm(bpForm, data=msrepRegData)
bpStat=summary(bpMod)$r.squared*nrow(msrepRegData)
1-pchisq(bpStat, df=length(ivs))
residMod1=resid(mod1)^2
norm=sum(residMod1)/length(residMod1)
residModNorm1=residMod1/norm
bpForm2=formula(paste0('residModNorm1 ~', paste(ivs, collapse=' + ')))
bpMod2=lm(bpForm2, data=msrepRegData)
tss=sum( (residModNorm1 - mean(residModNorm1))^2 )
rss=sum(resid(bpMod2)^2)
.5*(tss-rss)
bpStat
