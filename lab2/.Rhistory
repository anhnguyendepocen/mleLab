for(lib in toLoad){
if(! lib %in% installed.packages()[,1])
{ install.packages(lib, repos='http://cran.rstudio.com/') }
suppressMessages( library(lib, character.only=TRUE) ) }
}
# Load libraries
packs=c("ggplot2", 'ggthemes', 'MASS', 'arm')
loadPkg(packs)
# Set a theme for gg
theme_set(theme_bw())
theme_set(theme_economist())
# Functions that I use frequently
char = function(x){ as.character(x) }
num = function(x){ as.numeric(char(x)) }
# Relevant paths
lab2Path='~/Dropbox/Duke/Spring 2015/PS 733/lab2'
msrepPath=paste0(lab2Path, "/Msrepl87.asc")
msrep = read.table(msrepPath, header=TRUE)
# Create silly logged version of DV
msrep$deaths75ln = log(msrep$deaths75+1)
# Create logs of other things
msrep$deaths70ln = log(msrep$deaths70+1)
msrep$sanctions75ln = log(msrep$sanctions75+1)
msrep$sanctions70ln = log(msrep$sanctions70+1)
msrep$energypcln = log(msrep$energypc+1)
# Running a linear regression
ivs=c('upper20', 'energypcln', 'intensep',
'sanctions70ln', 'sanctions75ln', 'deaths70ln')
olsForm=formula(
paste0('deaths75ln ~ ',
paste(ivs, collapse=' + ') )
)
mod1 = lm(olsForm, data=msrep)
# View model results
summary(mod1)
coefplot(mod1)
varName=rownames(summary(mod1)$coefficients)
varName=c('Intercept', 'Upper 20% Income Share, 1970',
'Ln(Energy Cons.), 1970', 'Separatism, 1975',
'Ln(Sanctions), 1968-72', 'Ln(Sanctions), 1973-77',
'Ln(Deaths), 1968-72')
mean=summary(mod1)$coefficients[,1]
serror=summary(mod1)$coefficients[,2]
# Calculate confidence intervals around regression estimates
up95=mean+qnorm(0.975)*serror
lo95=mean-qnorm(0.975)*serror
up90=mean+qnorm(0.95)*serror
lo90=mean-qnorm(0.95)*serror
# Combine in dataframe
coefData=cbind(varName, mean, serror, up95, lo95, up90, lo90)
coefData=data.frame(coefData, row.names=NULL)
# Check class of variables in dataframe
class(coefData$up95)
# Lets clean this up
convNumDcol=function(data, vars){
for(var in vars){ data[,var]=num(data[,var]) }
return( data ) }
coefData=convNumDcol(coefData, names(coefData)[2:length(coefData)])
# Lets check to make sure class is correct now
class(coefData$up95)
summary(mod1)$coefficients
sqrt(diag(vcov(mod1)))
(t(residuals)%*%residuals)/(df.residual(mod1))
t(residuals)
(t(resid(mod1))%*%resid(mod1))/(df.residual(mod1))
(t(resid(mod1)) * resid(mod1))/(df.residual(mod1))
(t(resid(mod1)) * resid(mod1))
(t(resid(mod1)) %*% resid(mod1))
(t(resid(mod1)) * resid(mod1))/(df.residual(mod1))
(t(resid(mod1))%*%resid(mod1))/(df.residual(mod1))
summary(mod1)
sum(resid(mod1))^2/(df.residual(mod1))
sum(resid(mod1)^2)/(df.residual(mod1))
X=msrep[,ivs]
X=na.omit(msrep[,ivs])
sum(resid(mod1)^2)/(df.residual(mod1))
(sum(resid(mod1)^2)/(df.residual(mod1))) * solve(t(X) %*% X)
solve(t(X) %*% X)
dim(X)
dim(t(X))
head(X)
X=as.matrix(na.omit(msrep[,ivs]))
(sum(resid(mod1)^2)/(df.residual(mod1))) * solve(t(X) %*% X)
vcov(mod1)
solve(t(X) %*% X)
vcov
?vcov
(sum(resid(mod1)^2)/(df.residual(mod1)))
coef(mod1)
head(mod1)
X=cbind(1,as.matrix(na.omit(msrep[,ivs])))
head(X)
(sum(resid(mod1)^2)/(df.residual(mod1))) * solve(t(X) %*% X)
vcov(mod1)
y=as.matrix(na.omit(msrep[,c('deaths75ln', ivs)]))
head(y)
y=y[,1]
solve(t(X) %*% X) t(X) %*% y
t(X)
solve(t(X) %*% X)
solve(t(X) %*% X) %*% t(X) %*% y
coef(mod1)
rm(list=ls())
# Function to load packages
loadPkg=function(toLoad){
for(lib in toLoad){
if(! lib %in% installed.packages()[,1])
{ install.packages(lib, repos='http://cran.rstudio.com/') }
suppressMessages( library(lib, character.only=TRUE) ) }
}
# Load libraries
packs=c("ggplot2", 'ggthemes', 'MASS', 'arm')
loadPkg(packs)
# Set a theme for gg
theme_set(theme_bw())
theme_set(theme_economist())
# Functions that I use frequently
char = function(x){ as.character(x) }
num = function(x){ as.numeric(char(x)) }
# Relevant paths
lab2Path='~/Dropbox/Duke/Spring 2015/PS 733/lab2'
installed.packages()[,1]
msrepPath=paste0(lab2Path, "/Msrepl87.asc")
msrep = read.table(msrepPath, header=TRUE)
# Create silly logged version of DV
msrep$deaths75ln = log(msrep$deaths75+1)
# Create logs of other things
msrep$deaths70ln = log(msrep$deaths70+1)
msrep$sanctions75ln = log(msrep$sanctions75+1)
msrep$sanctions70ln = log(msrep$sanctions70+1)
msrep$energypcln = log(msrep$energypc+1)
# Running a linear regression
ivs=c('upper20', 'energypcln', 'intensep',
'sanctions70ln', 'sanctions75ln', 'deaths70ln')
olsForm=formula(
paste0('deaths75ln ~ ',
paste(ivs, collapse=' + ') )
)
mod1 = lm(olsForm, data=msrep)
# View model results
summary(mod1)
coefplot(mod1)
varName=rownames(summary(mod1)$coefficients)
varName
varName=c('Intercept', 'Upper 20% Income Share, 1970',
'Ln(Energy Cons.), 1970', 'Separatism, 1975',
'Ln(Sanctions), 1968-72', 'Ln(Sanctions), 1973-77',
'Ln(Deaths), 1968-72')
varName
mean=summary(mod1)$coefficients[,1]
mean
serror=summary(mod1)$coefficients[,2]
serror
serror
mean
summary(mod1)
class(summary(mod1))
attributes(summary(mod1))
summary(mod1)
summary(mod1)$coefficients
summary(mod1)$coefficients[,1]
summary(mod1)$coefficients[,2]
qnorm(0.975)
qt(0.975, 5)
?mapply
mapply(function(x, y){plusMin(x)} rep(mean,2), c(serror*qnorm(0.975), serror*qnorm(0.95)))
rep(mean, 2)
mapply(function(x, y){plusMin(x)}, x=rep(mean,2), y=c(serror*qnorm(0.975), serror*qnorm(0.95)))
plusMin=function(x,y){c(x+y,x-y)}
mapply(function(x, y){plusMin(x)}, x=rep(mean,2), y=c(serror*qnorm(0.975), serror*qnorm(0.95)))
c(serror*qnorm(0.975), serror*qnorm(0.95))
mapply(function(x, y){plusMin(x, y)}, x=rep(mean,2), y=c(serror*qnorm(0.975), serror*qnorm(0.95)))
ciprobs=c(.975,.025,.95,.05)
cis=NULL
for(i in 1:4) {
cis[[i]] = mean + qnorm(ciprobs[i]) * serror
}
cis
qnorm(ciprobs[i])
for(i in ciprobs){print(i)}
cisMat=do.call('cbind', cis)
cisMat
cis=matrix(NA, nrow=length(means), ncol=4)
cis=matrix(NA, nrow=length(means), ncol=length(ciprobs))
cis=matrix(NA, nrow=length(mean), ncol=length(ciprobs))
cis
cis=matrix(NA, nrow=length(mean), ncol=length(ciprobs), dimnames=list(NULL, c('up95','lo95', 'up90', 'lo90')))
cis
i=1
mean + qnorm(ciprobs[i]) * serror
ciprobs[i]
cis[,i]
ciprobs=c(.975,.025,.95,.05)
cis=matrix(NA, nrow=length(mean), ncol=length(ciprobs), dimnames=list(NULL, c('up95','lo95', 'up90', 'lo90')))
for(i in 1:ncol(cis)) {
cis[,i] = mean + qnorm(ciprobs[i]) * serror
}
cis
cis=NULL
for(i in 1:ncol(cis)) {
cis[,i] = mean + qnorm(ciprobs[i]) * serror
}
cis
plusMin=function(x,y){c(x+y,x-y)}
mapply(function(x, y){plusMin(x, y)}, x=rep(mean,2), y=c(serror*qnorm(0.975), serror*qnorm(0.95)))
t(mapply(function(x, y){plusMin(x, y)}, x=rep(mean,2), y=c(serror*qnorm(0.975), serror*qnorm(0.95))))
plusMin=function(x,y){cbind(x+y,x-y)}
mapply(function(x, y){plusMin(x, y)}, x=rep(mean,2), y=c(serror*qnorm(0.975), serror*qnorm(0.95)))
plusMin=function(x,y){cbind(x+y,x-y)}
t(mapply(function(x, y){plusMin(x, y)}, x=rep(mean,2), y=c(serror*qnorm(0.975), serror*qnorm(0.95))))
varName=rownames(summary(mod1)$coefficients)
varName=c('Intercept', 'Upper 20% Income Share, 1970',
'Ln(Energy Cons.), 1970', 'Separatism, 1975',
'Ln(Sanctions), 1968-72', 'Ln(Sanctions), 1973-77',
'Ln(Deaths), 1968-72')
mean=summary(mod1)$coefficients[,1]
serror=summary(mod1)$coefficients[,2]
# Calculate confidence intervals around regression estimates
#### Calculate these values:
##### Hint use qnorm to determine appropriate test statistic value
plusMin=function(x,y){cbind(x+y,x-y)}
t(mapply(function(x, y){plusMin(x, y)}, x=rep(mean,2), y=c(serror*qnorm(0.975), serror*qnorm(0.95))))
ciprobs=c(.975,.025,.95,.05)
cis=matrix(NA, nrow=length(mean), ncol=length(ciprobs), dimnames=list(NULL, c('up95','lo95', 'up90', 'lo90')))
for(i in 1:ncol(cis)) {
cis[,i] = mean + qnorm(ciprobs[i]) * serror
}
cis
up95=mean+qnorm(0.975)*serror
lo95=mean-qnorm(0.975)*serror
up90=mean+qnorm(0.95)*serror
lo90=mean-qnorm(0.95)*serror
# Combine in dataframe
coefData=cbind(varName, mean, serror, up95, lo95, up90, lo90)
coefData=data.frame(coefData, row.names=NULL)
coefData
class(coefData$up95)
coefData=data.frame(varName, mean, serror, up95, lo95, up90, lo90)
coefData
class(coefData$up95)
coefData=data.frame(varName, mean, serror, up95, lo95, up90, lo90)
apply(coefData, 2, class)
head(coefData)
class(coefData$90)
class(coefData$lo90)
str(coefData)
names(coefData)[2:length(coefData)]
# Combine in dataframe
coefData=cbind(varName, mean, serror, up95, lo95, up90, lo90)
coefData=data.frame(coefData, row.names=NULL)
# Check class of variables in dataframe
class(coefData$up95)
# Lets clean this up
### Create function that goes through selected columns of a dataset
#### and converts the selected column to a numeric vector
#### The output of this function should be the revised dataframe
#### with appropriate columns changed to numeric
#### Hint: A function for loop would be a simple approach
convNumDcol=function(data, vars){
for(var in vars){ data[,var]=num(data[,var]) }
return( data ) }
coefData=convNumDcol(coefData, names(coefData)[2:length(coefData)])
str(coefData)
class(coefData$up95)
coefData
coefData[-1,]
tmp=ggplot(data=coefData[-1,], aes(x=varName))
tmp=tmp + geom_linerange(aes(ymin=lo95, ymax=up95), size=.3)
tmp=tmp + geom_linerange(aes(ymin=lo90, ymax=up90), size=1)
tmp=tmp + geom_point(aes(y=mean))
tmp=tmp + geom_hline(yintercept=0, linetype=2, color = "red")
tmp=tmp + coord_flip() + xlab('') + ylab('')
tmp=tmp + theme(axis.ticks=element_blank())
tmp
sims = 1000  	# number of simulations
doors = c(1,2,3)	# doors
sample(doors,1)
sample(doors,1)
WinDoor==choice
DoorsLeft = c(WinDoor, sample(doors[doors!=WinDoor],1))
WinDoor = sample(doors,1)		# randomly pick a winning door
choice = sample(doors,1)		# randomly pick a door
WinDoor==choice
c(WinDoor, sample(doors[doors!=WinDoor],1))
WinDoor
choice
c(WinDoor, sample(doors[doors!=WinDoor],1))
DoorsLeft = c(WinDoor, sample(doors[doors!=WinDoor],1))
DoorsLeft
WinDoor = sample(doors,1)		# randomly pick a winning door
choice = sample(doors,1)		# randomly pick a door
# now one door is opened and only 2 remain:
if(WinDoor==choice) DoorsLeft = c(WinDoor, sample(doors[doors!=WinDoor],1))
set.seed(6886)
WinDoor = sample(doors,1)		# randomly pick a winning door
choice = sample(doors,1)		# randomly pick a door
# now one door is opened and only 2 remain:
if(WinDoor==choice) DoorsLeft = c(WinDoor, sample(doors[do
ors!=WinDoor],1))
if(WinDoor==choice) DoorsLeft = c(WinDoor, sample(doors[doors!=WinDoor],1))
WinDoor
choice
DoorsLeft
WinDoor = sample(doors,1)		# randomly pick a winning door
choice = sample(doors,1)		# randomly pick a door
WinDoor
choice
c(WinDoor, choice)
noswitch = choice
DoorsLeft!=choice
DoorsLeft[DoorsLeft!=choice]
sims = 1000  	# number of simulations
doors = c(1,2,3)	# doors
WinNoSwitch = WinSwitch = 0	# these two will count the number of wins when switching and not switching.
for(i in 1:sims){				# the loop
WinDoor = sample(doors,1)		# randomly pick a winning door
choice = sample(doors,1)		# randomly pick a door
# now one door is opened and only 2 remain:
if(WinDoor==choice) DoorsLeft = c(WinDoor, sample(doors[doors!=WinDoor],1))
# if you picked the right door initially, they will randomly open one of the others
if(WinDoor!=choice) DoorsLeft = c(WinDoor, choice)
# if you picked the wrong door initially, they will keep yours and the winning door
# choice whether to switch or not
noswitch = choice
switch = DoorsLeft[DoorsLeft!=choice]
# if you win, add 1 to the respective counter
if(noswitch==WinDoor) WinNoSwitch = WinNoSwitch+1
if(switch==WinDoor) WinSwitch = WinSwitch+1
}
paste("Probability | No Switch = ",WinNoSwitch/sims,"", sep="")
paste("Probability | Switch = ",WinSwitch/sims,"", sep="")
sims = 1000
people = 23
days = seq(1,365,1)
sameday = 0
?sample
birthdays = sample(days, people, replace=TRUE)
birthdays
length(unique(birthdays))
length(unique(birthdays))<people
sims = 1000
people = 23
days = seq(1,365,1)
sameday = 0
# Complete the for loop below, what should birthdays equal
# Determine the condition to add 1 to sameday
for(i in 1:sims){
birthdays = sample(days, people, replace=TRUE)
if( length(unique(birthdays))<people ) sameday = sameday+1
}
paste0("Probability at least 2 people with same birthday = ",sameday/sims,"")
draws = mvrnorm(sims, coef(mod1), vcov(mod1))
head(draws)
means=apply(msrep[,ivs], 2, function(x){ mean(x, na.rm=TRUE) })
means
minMaxSep=quantile(msrep[,ivs[1]], probs=c(0,1), na.rm=TRUE)
minMaxSep
scens=rbind(c(1, minMaxSep[1], means[2:length(means)]),
c(1, minMaxSep[2], means[2:length(means)]) )
scens
means=apply(msrep[,ivs], 2, function(x){ mean(x, na.rm=TRUE) })
minMaxSep=quantile(msrep[,ivs[1]], probs=c(0,1), na.rm=TRUE)
scens=rbind(c(1, minMaxSep[1], means[2:length(means)]),
c(1, minMaxSep[2], means[2:length(means)]) )
# Simulate additional parameter estimates from multivariate normal
sims=1000
draws = mvrnorm(sims, coef(mod1), vcov(mod1))
dim(draws)
dim(scen)
dim(scens)
preds=draws %*% t(scens)
head(Preds)
head(preds)
summary(preds)
plot(density(preds[,1]), col = "red", bty = "n",
las = 1, xlim=c(-4, 10), lwd = 3, main='', ylim=c(0,1),
xlab = "Logged Average Deaths per Million")
lines(density(preds[,2]), col = "blue", lwd = 3)
legend(x=-.4,y=.95,legend=c("Low upper20"),
text.col=c("red"),bty="n", cex = 0.75)
legend(x=3.7,y=0.95,legend=c("High upper20"),
text.col=c("blue"),bty="n", cex = 0.75)
means=apply(msrep[,ivs], 2, function(x){ mean(x, na.rm=TRUE) })
minMaxSep=quantile(msrep[,ivs[1]], probs=c(.25,.75), na.rm=TRUE)
scens=rbind(c(1, minMaxSep[1], means[2:length(means)]),
c(1, minMaxSep[2], means[2:length(means)]) )
# Simulate additional parameter estimates from multivariate normal
sims=1000
draws = mvrnorm(sims, coef(mod1), vcov(mod1))
# Get predicted values using matrix multiplication
dim(draws)
dim(scens)
preds=draws %*% t(scens)
#plotting sim results
plot(density(preds[,1]), col = "red", bty = "n",
las = 1, xlim=c(-4, 10), lwd = 3, main='', ylim=c(0,1),
xlab = "Logged Average Deaths per Million")
lines(density(preds[,2]), col = "blue", lwd = 3)
legend(x=-.4,y=.95,legend=c("Low upper20"),
text.col=c("red"),bty="n", cex = 0.75)
legend(x=3.7,y=0.95,legend=c("High upper20"),
text.col=c("blue"),bty="n", cex = 0.75)
summary(preds)
means=apply(msrep[,ivs], 2, function(x){ mean(x, na.rm=TRUE) })
minMaxSep=quantile(msrep[,ivs[1]], probs=c(0,1), na.rm=TRUE)
scens=rbind(c(1, minMaxSep[1], means[2:length(means)]),
c(1, minMaxSep[2], means[2:length(means)]) )
# Simulate additional parameter estimates from multivariate normal
sims=1000
draws = mvrnorm(sims, coef(mod1), vcov(mod1))
# Get predicted values using matrix multiplication
dim(draws)
dim(scens)
preds=draws %*% t(scens)
#plotting sim results
plot(density(preds[,1]), col = "red", bty = "n",
las = 1, xlim=c(-4, 10), lwd = 3, main='', ylim=c(0,1),
xlab = "Logged Average Deaths per Million")
lines(density(preds[,2]), col = "blue", lwd = 3)
legend(x=-.4,y=.95,legend=c("Low upper20"),
text.col=c("red"),bty="n", cex = 0.75)
legend(x=3.7,y=0.95,legend=c("High upper20"),
text.col=c("blue"),bty="n", cex = 0.75)
sigma=sqrt( sum(resid(mod1)^2)/(df.residual(mod1)) )
sigma
exp=cbind(rnorm(sims, preds[,1], sigma), rnorm(sims, preds[,2], sigma))
head(exp)
plot(density(preds[,1]), col = "red", bty = "n",
las = 1, xlim=c(-4, 10), lwd = 3, main='', ylim=c(0,1),
xlab = "Logged Average Deaths per Million")
lines(density(preds[,2]), col = "blue", lwd = 3)
legend(x=-.4,y=.95,legend=c("Low upper20"),
text.col=c("red"),bty="n", cex = 0.75)
legend(x=3.7,y=0.95,legend=c("High upper20"),
text.col=c("blue"),bty="n", cex = 0.75)
# Add lines with fundamental uncertainty
lines(density(exp[,1]), col='coral', lwd=3)
lines(density(exp[,2]), col='cornflowerblue', lwd=3)
rm(list=ls())
# Function to load packages
loadPkg=function(toLoad){
for(lib in toLoad){
if(! lib %in% installed.packages()[,1])
{ install.packages(lib, repos='http://cran.rstudio.com/') }
suppressMessages( library(lib, character.only=TRUE) ) }
}
# Load libraries
packs=c("ggplot2", 'ggthemes', 'MASS', 'arm')
loadPkg(packs)
# Set a theme for gg
theme_set(theme_bw())
theme_set(theme_economist())
# Functions that I use frequently
char = function(x){ as.character(x) }
num = function(x){ as.numeric(char(x)) }
# Relevant paths
lab2Path='~/Dropbox/Duke/Spring 2015/PS 733/lab2'
msrepPath=paste0(lab2Path, "/Msrepl87.asc")
msrep = read.table(msrepPath, header=TRUE)
# Create silly logged version of DV
msrep$deaths75ln = log(msrep$deaths75+1)
# Create logs of other things
msrep$deaths70ln = log(msrep$deaths70+1)
msrep$sanctions75ln = log(msrep$sanctions75+1)
msrep$sanctions70ln = log(msrep$sanctions70+1)
msrep$energypcln = log(msrep$energypc+1)
# Running a linear regression
ivs=c('upper20', 'energypcln', 'intensep',
'sanctions70ln', 'sanctions75ln', 'deaths70ln')
olsForm=formula(
paste0('deaths75ln ~ ',
paste(ivs, collapse=' + ') )
)
mod1 = lm(olsForm, data=msrep)
# View model results
summary(mod1)
varName=rownames(summary(mod1)$coefficients)
varName=c('Intercept', 'Upper 20% Income Share, 1970',
'Ln(Energy Cons.), 1970', 'Separatism, 1975',
'Ln(Sanctions), 1968-72', 'Ln(Sanctions), 1973-77',
'Ln(Deaths), 1968-72')
mean=summary(mod1)$coefficients[,1]
serror=summary(mod1)$coefficients[,2]
# Calculate confidence intervals around regression estimates
up95=mean+qnorm(0.975)*serror
lo95=mean-qnorm(0.975)*serror
up90=mean+qnorm(0.95)*serror
lo90=mean-qnorm(0.95)*serror
# Combine in dataframe
coefData=cbind(varName, mean, serror, up95, lo95, up90, lo90)
coefData=data.frame(coefData, row.names=NULL)
# Check class of variables in dataframe
class(coefData$up95)
# Lets clean this up
convNumDcol=function(data, vars){
for(var in vars){ data[,var]=num(data[,var]) }
return( data ) }
coefData=convNumDcol(coefData, names(coefData)[2:length(coefData)])
# Lets check to make sure class is correct now
class(coefData$up95)
means=apply(msrep[,ivs], 2, function(x){ mean(x, na.rm=TRUE) })
minMaxSep=quantile(msrep[,ivs[1]], probs=c(0,1), na.rm=TRUE)
scens=rbind(c(1, minMaxSep[1], means[2:length(means)]),
c(1, minMaxSep[2], means[2:length(means)]) )
# Simulate additional parameter estimates from multivariate normal
sims=1000
draws = mvrnorm(sims, coef(mod1), vcov(mod1))
# Get predicted values using matrix multiplication
preds = draws %*% t(scens)
sigma = sqrt(sum(resid(mod1)^2)/df.residual(mod1))
apply(preds, 2, sd)
sigma
